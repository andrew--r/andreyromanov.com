Реакт очень популярен. Из-за этого многие новички используют его неправильно, не&nbsp;понимая, какую задачу он&nbsp;решает.

Основные задачи, которые нужно решить при разработке веб-приложения:

- управление состоянием приложения;
- общение с&nbsp;сервером;
- роутинг (изменение урла при переходах между страницами);
- разработка интерфейса. _← за&nbsp;это отвечает Реакт_

Как видите, Реакт отвечает только за&nbsp;построение интерфейса. Реакт не&nbsp;отвечает за&nbsp;программирование бизнес-логики. Реакт не&nbsp;отвечает за&nbsp;роутинг. Реакт не&nbsp;отвечает за&nbsp;общение с&nbsp;сервером. Из&nbsp;всего этого вытекает несколько простых правил.

<div class="aside">
  <p class="aside__paragraph"><b>Не&nbsp;пишите бизнес-логику в&nbsp;Реакт-компонентах.</b> Логика приложения должна быть скрыта в&nbsp;отдельном модуле, который предоставляет наружу простой и&nbsp;декларативный API, которым можно пользоваться даже через консоль, без UI. Это позволит вам разрабатывать логику и&nbsp;UI независимо друг от&nbsp;друга, а&nbsp;также сильно упростить тестирование логики.</p>

  <aside class="aside__note">
    Как разделять логику и&nbsp;представление приложения? <a href="https://youtu.be/3J9EJrvqOiM">Доклад</a> и&nbsp;<a href="https://hackernoon.com/cc90b787aa37">статья</a> создателя MobX Мишеля Вестрате
  </aside>
</div>

<div class="aside">
  <p class="aside__paragraph"><b>Не&nbsp;используйте Реакт для роутинга.</b> React Router это очень популярная библиотека с&nbsp;нескольким десятком тысяч звёзд на&nbsp;Гитхабе, но&nbsp;серьёзно, она провоцирует разработчиков творить ужасные вещи. Она заставит вас нарушить предыдущий пункт и&nbsp;писать бизнес-логику в&nbsp;компонентах. Она заставит вас относиться к&nbsp;URL как к&nbsp;ещё одному источнику состояния приложения. Она заставит вас смешать вёрстку и&nbsp;настройки роутера (а&nbsp;в&nbsp;четвёртой версии появляется возможность раскидать настройки роутера вообще по&nbsp;всему приложению). Роутинг относится к&nbsp;логике приложения. URL должен зависеть от&nbsp;состояния приложения, а&nbsp;не&nbsp;наоборот. Это значит, что URL должен меняться автоматически при изменении состояния приложения. Обращаться к&nbsp;URL для чтения каких-то данных нельзя вообще никогда, кроме момента инициализации приложения (в&nbsp;момент инициализации можно использовать данные из&nbsp;URL для задания исходного состояния приложения).</p>

  <aside class="aside__note">
    Примеры нормальных роутеров, автоматически синхронизирующих в&nbsp;обе стороны состояние и&nbsp;URL приложения: <a href="https://github.com/faceyspacey/redux-first-router">redux-first-router</a> и&nbsp;<a href="https://github.com/kitze/mobx-router">mobx-router</a>
  </aside>
</div>

**Не&nbsp;используйте Реакт для общения с&nbsp;сервером.** Серьёзно, я&nbsp;видел компоненты вроде `<Fetch url='...' />` &mdash; пожалуйста, не&nbsp;делайте так. За&nbsp;общение с&nbsp;сервером должен отвечать отдельный модуль, скрывающий детали реализации и&nbsp;предоставляющий абстрактный API вроде `articles.get({ id: 1 }).then((article) => {})`.
